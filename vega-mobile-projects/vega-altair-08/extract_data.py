import json
import re
import os

def extract_and_process():
    html_path = 'original_visualization/desktop.html'
    output_path = 'src/lib/data.ts'

    if not os.path.exists(html_path):
        print(f"Error: {html_path} does not exist.")
        return

    with open(html_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # Find the start of the JSON spec
    start_marker = 'var spec = '
    start_index = content.find(start_marker)
    if start_index == -1:
        print("Could not find spec JSON start in HTML")
        return
    
    start_index += len(start_marker)
    
    # Simple brace counting to find the end of the JSON object
    brace_count = 0
    end_index = -1
    in_string = False
    escape = False
    
    for i in range(start_index, len(content)):
        char = content[i]
        
        if escape:
            escape = False
            continue
            
        if char == '\\':
            escape = True
            continue
            
        if char == '"':
            in_string = not in_string
            continue
            
        if not in_string:
            if char == '{':
                brace_count += 1
            elif char == '}':
                brace_count -= 1
                if brace_count == 0:
                    end_index = i + 1
                    break
    
    if end_index == -1:
        print("Could not find spec JSON end in HTML")
        return

    spec_str = content[start_index:end_index]
    
    try:
        spec = json.loads(spec_str)
    except json.JSONDecodeError as e:
        print(f"Error parsing JSON: {e}")
        return

    # Extract raw data
    datasets = spec.get('datasets', {})
    raw_data = []
    # Find the dataset key that looks like data-xxxxx
    for key, val in datasets.items():
        if key.startswith('data-'):
            raw_data = val
            break
            
    # If not found, check if 'data' property exists and has 'values' (inline data)
    if not raw_data and 'data' in spec and 'values' in spec['data']:
         raw_data = spec['data']['values']

    if not raw_data:
        print("Could not find data in datasets or inline")
        return

    # Process data
    # Group by variety -> site -> sum yield
    grouped = {}
    
    for item in raw_data:
        variety = item['variety']
        site = item['site']
        yield_val = item['yield']
        
        if variety not in grouped:
            grouped[variety] = {}
        
        if site not in grouped[variety]:
            grouped[variety][site] = 0
            
        grouped[variety][site] += yield_val

    # Convert to target structure
    processed_data = []
    for variety, sites in grouped.items():
        total_yield = sum(sites.values())
        processed_data.append({
            "name": variety,
            "total": total_yield,
            "sites": sites
        })

    # Sort by total yield descending
    processed_data.sort(key=lambda x: x['total'], reverse=True)

    # Identify all unique sites
    all_sites = set()
    for item in raw_data:
        all_sites.add(item['site'])
    
    # Generate TypeScript content
    ts_content = f"// Generated by extract_data.py\n\nexport interface SiteYields {\n    [key: string]: number;\n}\n\nexport interface ChartItem {\n    name: string;\n    total: number;\n    sites: SiteYields;\n}\n\nexport const allSites = {json.dumps(sorted(list(all_sites)), indent=2)};\n\nexport const data: ChartItem[] = {json.dumps(processed_data, indent=2)};
"

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(ts_content)

    print(f"Successfully wrote data to {output_path}")

if __name__ == '__main__':
    extract_and_process()
